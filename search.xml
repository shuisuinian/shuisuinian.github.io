<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle基础2]]></title>
    <url>%2Farchives%2F3771320040.html</url>
    <content type="text"><![CDATA[sql结构化查询语言本文延续上一篇内容oracle基础 本文用例中用到的表123456789101112-- emp表--员工信息表create table EMP( empno NUMBER(4) not null, ename VARCHAR2(10), job VARCHAR2(9), mgr NUMBER(4), hiredate DATE, sal NUMBER(7,2), comm NUMBER(7,2), deptno NUMBER(2)) 排序查询 降序 select * from 表名 order by 字段名 desc 升序 select * from 表名 order by 字段名 asc 例1: 查询所有员工信息，按照工资从高到低排序 1select * from emp order by sal desc; 例2: 查询20部门中的员工信息，按工资从高到低，如果工资相等，再按奖金从低到高排序 1select * from emp where deptno = 10 order by sal desc,comm asc ; 结果去重 distinct 未使用distinct 1select job from emp; 结果 使用 distinct 1select distinct job from emp; 结果 数据库索引 索引是一种额数的查询表，可以加快数据的检索 类似于书的目录，不需要查询整本数内容就可以找到想要的数据 缺点：减慢了数据的录入速度，同时增加了数据库的尺寸大小 oracle 常用的索引 normal unique 唯一索引 适合建立在值不重复的字段上 主键默认就会建立一个唯一索引 bitmap 适合建立在只有某几个值的字段 （如性别字段） 什么样的字段适合建立索引 经常被查询的字段 不为空且字段值不重复 字段的值不警察修改 创建索引的命令create 索引类型 index 索引名 on 表名 (字段名); 例: 1create unique index UK_USER_IDCARD on T_USER (IDCARD) 序列 Sequences 是一种特殊的数据对象，一般用来自增 123456789-- Create sequence create sequence seq_sno --seq_sno是序列名minvalue 1 --最小值：下次循环开始的值maxvalue 9999999 --最大值start with 1 --初始值：第一次开始的值increment by 1 --增量cache 20 --缓存：cycle --循环：不写这一条，默认不循环order; --排序 使用 1insert into 表名(id) values(seq_sno.nextval); 伪列rownum和rowidrowid和rownum都是序列，但含义完全不同 rowid是物理地址，用于定位oracle中具体数据的物理存储位置，rownum则是sql的输出结果排序。通俗的讲：rowid是相对不变的，rownum会变化，尤其是使用order by的时候 rownum表示查询某条记录在整个结果集中的位置，同一条记录查询条件不同对应的rownum是不同的而rowid是不会变的 在oracle中，要按特定条件查询前n条记录，用rownum就可以了。select * from emp where rownum&lt;3; 这里要注意的是不能对rownum用’’&gt;’’,也就是说如果用select * from emp where rownum&gt;3;查询的结果是失败的。 原因:对应rownum来说它是oracle系统顺序分配为从查询返回的行的编号，返回的第一行分配的是1，第二行是2，以此内推，这个伪字段可以用于限制查询返回的总行数，因为rownum都是从1开始，但是1以上的自然数在rownum做判断时认为都是false条件，所有无法查到rownum=n（n&gt;1的自然数）。 rowid同ROWNUM伪列不同的是，它是物理存在的，ROWID是一种数据类型，它使用基于64为编码的18个字符来唯一标识一条记录物理位置的一个ID，类似于Java中一个对象的哈希码，都是为了唯一标识对应对象的物理位置，需要注意的是ROWID虽然可以在表中进行查询，但是其值并未存储在表中，所以不支持增删改操作 ROWID由18个字符组成，组成结构如下： 数据对象编号 文件编号 块编号 行编号 OOOOOO FFF BBBBBB RRR 由于ROWID用来唯一标识表中数据的唯一性，所以可以利用这个特性去除重复 oracle 常见的系统函数 sysdate 获取系统时间 1select sysdate from dual; 结果: length 获取字符长度 1select length(&apos;abc中文&apos;) from dual; 结果: lengthb 获取字节数 1select lengthb(&apos;abc中文&apos;) from dual; 结果: upper 把字符转换为大写 lower 把字符转换为小写 substr 截取字符串 substr(str,offset,len) 从offset位置开始截取冷儿字符 1select substr(&apos;abcdefg&apos;,1,4) from dual; --返回abcd instr 查找子字符串 instr(str,str2,pos,[times]) 从str的pos位置开始查找str2出现的位置，如果没找到，返回0，times是找第几次出现的位置 replace 子字符串替换 replace(str1,str2,str3) 把str1中的所有str2替换成str3 trim 去除前后空格 1select trim(&apos; abcd &apos;) from dual; --返回abcd to_number 把字符串转换为数字类型 1select to_number(&apos;12312312&apos;) from dual; --返回number类型 12312312 to_char 把某些特殊数据转换为字符串 12345678select to_char(sysdate,&apos;yyyy--MM-dd&apos;) from dual;-- 指定了日期显示按yyyy--MM-dd显示select to_char(sysdate,&apos;DDD&apos;) from dual;-- 返回指定日期是那一年的第几天select to_char(sysdate,&apos;DD&apos;) from dual;-- 返回指定日期是那一月的第几天select to_char(sysdate,&apos;D&apos;) from dual;-- 返回指定日期是那一周的第几天 to_date 把字符串日期数据 转换为日期类型 1select to_date(&apos;2019-07-10 15:08:09&apos;,&apos;yyyy-MM-dd HH24:mi:ss&apos;) from dual; 结果: 12-- 如果要添加的数据是 类似于birthday这种数据，则需要用到这个insert into t_user(id,birthday) values(11,to_date(&apos;2019-07-10 15:08:09&apos;,&apos;yyyy-MM-dd HH24:mi:ss&apos;)); 日期相关 获取当前日期前4年的时间 select sysdate,sysdate-interval &#39;4&#39; year from dual; 获取当前日期前4月的时间 select sysdate,sysdate-interval &#39;4&#39; month from dual; 获取当前日期前4天的时间 select sysdate,sysdate-interval &#39;4&#39; day from dual; 获取当前日期前4小时的时间 select sysdate,sysdate-interval &#39;4&#39; hour from dual; 获取当前日期前4分钟的时间 select sysdate,sysdate-interval &#39;4&#39; minute from dual; 获取两个日期相差的月份 select months_between(sysdate,to_date(&#39;2019-02-10&#39;,&#39;yyyy-MM-dd&#39;)) from dual; 在一个日期的基础上加上或减去相应的月份，返回新的日期 select add_months(sysdate,5) from dual; 返回指定日期的当月的最后一天 select last_day(sysdate) from dual; nvl(a,b) 如果a=null ，返回b，否则返回a nvl2(a,b,c) 如果a=null ，返回c，否则返回b decode(a,值1,结果1,值2,结果2,值3,结果3,默认值) 根据a等于那个值，返回相应结果，否则返回默认值 1select degree, decode (trunc(degree/10)*10,60,&apos;及格&apos;,70,&apos;良好&apos;,80,&apos;优秀&apos;,90,&apos;完美&apos;,&apos;继续努力&apos;) from t_score; 结果: 类似实现方法 case when语句 1234567select sal, case when sal&gt;3000 then &apos;高收入&apos; when sal&gt;2000 then &apos;中收入&apos; else &apos;低收入&apos; end 收入水平，ename,job from emp; 结果: 或者用于 更新数据操作，例: 根据工作不同 加不同的工资 12345678update emp set sal=case job when &apos;CLERK&apos; then nvl(sal,0)+200 when &apos;SALESMAN&apos; then nvl(sal,0)+300 when &apos;PRESIDENT&apos; then nvl(sal,0)+400 when &apos;MANAGER&apos; then nvl(sal,0)+500 when &apos;ANALYST&apos; then nvl(sal,0)+600 end; 聚合函数 max() 最大值 min() 最小值 avg() 平均值 count() 求总记录数（不统计为null的记录总数） sum() 求某个列的值加起来的总和 分组查询 group by 一般和聚合函数结合使用 例1:求出每个部门的最高工资 最低工资 工资总和 平均工资 部门人数 123456789--求出每个部门的最高工资 最低工资 工资总和 平均工资 部门人数select deptno 部门编号, max(sal) 最高工资, min(sal) 最低工资, sum(sal) 工资总和， avg(sal) 平均工资, count(*) 部门人数 from emp group by deptno; 结果: 例2: 查询员工数大于3的部门 1234567891011&gt; --查询员工数大于等于2的部门 select deptno 部门编号, max(sal) 最高工资, min(sal) 最低工资, sum(sal) 工资总和， avg(sal) 平均工资, count(*) 部门人数 from emp group by deptnohaving count(empno)&gt;3; --group 后用 having 关键字 结果: 例3: 行转列 将图1 经过查询后 转化为图2所示结果 图1 图2 1234select A ,sum(decode(B,&apos;胜&apos;,1)) 胜,sum(decode(B,&apos;负&apos;,1)) 负from t_sf group by A;]]></content>
      <categories>
        <category>jee学习之路</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle基础]]></title>
    <url>%2Farchives%2F323323423.html</url>
    <content type="text"><![CDATA[数据库 用来永久存储数据的一种c/s(client/server)软件系统 常用的关系型数据库 mysql oracle 数据库量大-千万级 db2 数据库量大-千万级 Microsoft sql server sysbase 数据库量大-千万级 关系数据库是由表和一些其他对象组成的 数据库表：数据库表类似于java中的类 对于软件开发人员来说，数据库是每天都要接触的系统，我们主要用数据库来做以下事情 增删改表结构 增删改查数据 优化数据库 管理数据库 oracle中常用的数据类型 数字类型 number number(5) 表示不超过5位整数 number(5,2) 小数后2位，整数部分最多3位，总长度不超过5位 字符串类型 可变长度的字符串类型 varchar2 例如：varchar2(10) 10代表的是字节总数，英文字符占1个字节，中文占2个字节 nvarchar2 例如：nvarchar2(10) 10代表的是字符最大个数，每个字符占两个字节 固定长度的字符串类型 char 例如：char(10) 10代表的是字节总数，英文字符占1个字节，中文占2个字节，不管实际的字符数量，多出的空间以空格填充 日期类型 date timestamp时间戳类型:用1970-1-1日 开始计算的毫秒数 大数据类型 blob 存放任意格式文件的数据类型，一般用来存储图片 clob 存储大量的字符数据类型 nclob 存储大量的字符数据类型 oracle命令oracle用户相关命令 创建用户的命令 create user 用户名 identified by 密码; 删除用户名及该用户名下的所有关联 drop user 用户名 cascade; 给用户赋予角色 grant resource,connect to 用户名; 把resource 和 connect 角色赋予用户 resource 和 connect 是oracle中的两个角色名，这两个角色分别具有一定的权限 举例： 在数据库中有以下操作 创建表 创建视图 连接登录数据库 创建存储过程 解锁账户（系统中默认 用户scott/tiger 默认是锁定的所以要解锁） alter user scott account unlock; 重设密码 alter user 用户名 identified by 1234 oracle 表相关命令 创建表 123456789create table t_user(id number(5) not null constraint pk_user_id primary key,name nvarchar2(5),money number(5,2),gold number(18),birthday date default sysdate,sex char(2) default &apos;男&apos;) 删除表 1drop table t_user; 修改表 添加主键的命令 12alter table t_user add constraint pk_user_id primary key (id) 添加外键的命令 可以先添加一个用户登录记录表 12345678-- 创建一个用户登录记录表-- 用户id，登录时间，登录ipcreate table t_login_history(id number(5) not null,login_dt date default sysdate,login_ip varchar2(20)) 添加外键 123alter table t_login_history add constraint fk_login_id foreign key (id) references t_user (id) 添加表的同时赋予外键 12345678create table t_login_history(id number(5) not null,login_dt date default sysdate,login_ip varchar2(20),constraint fk_login_id foreign key(id) references t_user (id)) 增加字段的命令 alter table 表名 add 字段名 列的属性; 1alter table t_login_history add c1 number(5); 修改字段的命令 alter table 表名 modify 字段名 列的属性; 1alter table t_login_history modify c2 nvarchar2(10); 删除字段的命令 alter table 表名 drop column 字段名; 1alter table t_login_history drop column c1; 清空表的数据 truncate table 表名; delete table 表名;只清除表中的数据 数据完整性为了实现数据完整性有以下手段: 主键:能唯一标识某条记录的列，不能为null 外键:引用自别的表的主键，外键可以为null not null default 唯一约束 unique 12alter table T_USER add constraint uk_user_name unique (NAME); 检测约束 字段&gt;值 and 字段&lt;值 （and是并且，or是或者） 例1:添加sex 检查约束 123alter table T_USER add constraint check_user_sex check (sex=&apos;男&apos; or sex=&apos;女&apos;); 例2:添加姓名长度的检查约束 123alter table T_USER add constraint CHECK_USER_NAME_LENGTH check (length(name) &gt;=6 and length(name) &lt;=10); sql结构化查询语言 新增数据的sql语法 12insert into 表名 values(值1,值2,...)--表中所有列都要对应赋值 12insert into 表名(列名a,列名b) values(值1,值2);--可以选择要增加的列 分别 赋值 修改数据的sql语法 update 表名 set name=&#39;张三&#39;,ename=&#39;zhangsan&#39;; 123update t_test set name=&apos;张三&apos;,ename=&apos;zhangsan&apos;;--表示 name和ename列 所有行的数据都修改 12update t_test set name=&apos;鳄鱼&apos; where id = 1;--表示 将id=1的 数据的name改为 鳄鱼 删除数据的sql语法 12delete from 表名 where 条件-- 如果没有条件 则全部清空 查询数据的sql语法 select 字段列表 from 表名 [条件] 1select sno,sname from t_student; 12select * from t_student;-- *号表示所有字段 select 字段1 别名,字段2 别名 from 表名 别名 [条件] 给每个字段取了一个别名 1select sno 学号,sname 姓名 from t_student 学生表; 创建一个表并且复制查询到的数据 1create table 表名 as select * from 表名; 一些例子 学生表: 12345678create table t_student(sno varchar2(20) not null, --学号sname varchar2(20) not null,--学生姓名ssex varchar2(10) not null, --性别sbirthday date, --生日class varchar2(20) --所在班级编号); 老师表: 123456789create table t_teacher (tno varchar2(10) not null, --老师编号tname varchar2(20) not null, --老师姓名tsex varchar2(20) not null, --老师性别tbirthday date not null, --生日prof varchar2(20), --职称depart varchar2(20) not null --部门); 查询案例: 1234567891011121314151617181920212223242526272829303132333435-- 查询所有学生信息select * from t_student;-- 查询所有学生的学号，姓名select sno,sname from t_student;-- 查询所有的女老师select * from t_teacher where tsex = &apos;女&apos;;-- 查询所有职称等于助教的老师select * from t_teacher where prof=&apos;助教&apos;;-- 查询所有男助教select * from t_teacher where prof=&apos;助教&apos; and tsex = &apos;男&apos;;-- 查询所有男老师或职称等于讲师的老师信息，或者职称等于助教的老师select * from t_teacher where (tsex = &apos;男&apos; and prof = &apos;讲师&apos;) or prof = &apos;助教&apos;;-- 查询男或女教师select * from t_teacher where tsex=&apos;男&apos; or tsex=&apos;女&apos;;select * from t_teacher where tsex in (&apos;男&apos;,&apos;女&apos;);-- 查询emp表中 job=CLERK或SALESMAN的员工信息select * from emp where job=&apos;CLERK&apos; or job=&apos;SALESMAN&apos;;select * from emp where job in(&apos;CLERK&apos;,&apos;SALESMAN&apos;);-- 查询年龄等于10或者20或者30所有学生信息select * from t_student where trunc((sysdate-sbirthday)/365) in (10,20,30);-- 查询年龄在20到45岁之间的所有学生信息select * from t_student wheretrunc((sysdate-sbirthday)/365) between 20 and 45;-- trunc()是把一个小数取整的函数 模糊查询 like查询 通配符：%表示任意字符，_表示一个字符 select* from 表名 where 字段 like &#39;&#39; 例子 123456789--查询姓李的所有老师信息select * from t_teacher where tname like &apos;李%&apos;;--查询姓名中包含 诚 字的所有老师信息select * from t_teacher where tname like &apos;%诚%&apos;;--查询工作非SALESMAN，CLERK的员工信息select * from emp where job&lt;&gt;&apos;SALESMAN&apos;and job&lt;&gt;&apos;CLERK&apos;;select * from emp where job not in(&apos;SALESMAN&apos;,&apos;CLERK&apos;);]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2Farchives%2F368864908.html</url>
    <content type="text"><![CDATA[进程和线程 进程 一个应用程序的实例 是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 线程 属于进程中的一个执行单元，线程是通过cpu执行的基本单元 一个进程中至少有一个主线程存在，主线程可以去申请子线程 cpu执行任务是通过调用进程中的线程一台电脑中 同时又很多个进程在运行状态这些进程，又同时有很多个线程在运行状态单核cpu 同一时间只能调用一个线程 java中一个main方法一个进程，并且开启一个主线程，每个线程有个ID，在java中线程类是Thread类 Thread.currentThread()获取当前线程运行实例对象Thread.currentThread().getId()获取当前运行的线程ID JVM启动时就启动了多个线程，至少有两个线程可以分析的出来 执行main函数的线程 该线程的任务代码都定义在main函数中 负责垃圾回收的线程 线程的状态 新建状态（New）：新创建了一个线程对象。 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 创建线程的方法在java中开启线程有3种方法： 继承Thread类 实现Runnable接口 线程池(这里暂时先不写了) 创建线程方式一：继承Thread类 定义一个类继承Thread类 覆盖Thead类中的run方法 为什么要覆盖run方法？ 创建线程的目的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行。而运行的制定代码就是这个执行路径的任务，jvm创建的主线程的任务都定义在主函数中 而自定义的线程它的任务在哪呢？ Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务的描述。这个任务即使通过Thread类中的run方法来体现，也就是说，run方法就是封装自定义线程运行任务的函数 run方法中定义就是线程要运行的任务代码 开启线程是为了运行指定代码，所以只有继承Thread类，并覆盖run方法。将运行的代码定义在run方法中即可 直接创建Thread的子类对象，并启动 object.start(); 创建线程方式二：通过接口的形式完成 Runnable的实现 定义类实现 implements Runnable 覆盖接口中的run 方法，将线程的任务代码封装到run方法中 通过Thread类创建线程对象，并将Runnable接口的子类对象最为Thread类的构造函数的参数进行传递 Thread t1 = new Thread(d); 调用线程对象的start方法开启线程 t1.start(); 线程中常用方法 Thread.yield( ) Java线程中的Thread.yield( )方法，译为线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行，注意是让自己或者其他线程运行，并不是单纯的让给其他线程。 yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！ synchronized synchronized加在方法前面就是方法锁,作用是保证同一时间只能有一个线程进入该方法执行 synchronized作用于对象 就是对象锁 对象锁是实例方法使用synchronized关键字后，如果是多个线程访问同个对象的sychronized块，是同步的，但是访问不同对象的话还是不同步的。 123456789User user = new User();synchronized(user)&#123; while(...)&#123; ... &#125; user.notify() 唤醒其中一个等待操作对象(wait)的线程 user.wait(); //当前线程睡眠 释放对象锁 //当前线程睡眠，直到被别人用notify或notifyAll唤醒该线程&#125; Object.wait()当前线程睡眠 释放对象锁Object.notify() 随机唤醒其中一个wait的线程Object.notifyAll() 唤醒所有wait中的线程Thread.sleep(20000); 睡眠 wait和sleep的区别：wait是object类的方法，sleep是Thread类的方法2个方法都可以让线程暂停运行但是wait会释放对象锁，sleep不会。 中断： 中断在java中主要有3个方法：interrupt(),sInterrupted()和interrupted()。 interrupt()，在一个线程中调用另一个线程的interrupt()方法，即会向那个线程发出信号——线程中断状态已被设置。至于那个线程何去何从，由具体的代码实现决定。 isInterrupted()，用来判断当前线程的中断状态(true or false)。 interrupted()是个Thread的static方法，用来恢复中断状态。 Thread. join(); join的意思是使得放弃当前线程的执行，并返回对应的线程 例如下面代码的意思就是：程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会 12345ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);t1.start();t1.join();t2.start(); 就这样吧]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架]]></title>
    <url>%2Farchives%2F2128322273.html</url>
    <content type="text"><![CDATA[java集合框架 从物理角度只有两种数据结构 连续存储 链式存储 从逻辑角度有很多种数据结构 顺序存储 链式存储 map 红黑树 … 集合框架被设计成要满足以下几个目标。 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。 以下内容，参考来自大佬 Collection Collection 是最基本的集合接口 List List接口是一个有序的 Collection使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 List接口又有两个常用的实现类ArrayList和LinkedList ArrayList ArrayList -&gt; List接口 -&gt; Collection接口ArrayList 底层就是数组 ArrayList数组线性表的特点为:类似数组的形式进行存储，因此它的随机访问速度极快。ArrayList数组线性表的缺点为:不适合于在线性表中间需要频繁进行插入和删除操作。因为每次插入和删除都需要移动数组中的元素。 如果在初始化ArrayList的时候没有指定初始化长度的话，默认的长度为10 ArrayList在增加新元素的时候如果超过了原始的容量的话，ArrayList扩容ensureCapacity的方案为原始容量*3/2 ArrayList是线程不安全的，在多线程的情况下不要使用 如果一定在多线程使用List的，您可以使用Vector，因为Vector和ArrayList基本一致，区别在于Vector中的绝大部分方法都 使用了同步关键字修饰，这样在多线程的情况下不会出现并发错误哦，还有就是它们的扩容方案不同，ArrayList是通过原始容量*3/2,而Vector是允许设置默认的增长长度，Vector的默认扩容方式为原来的2倍。 切记Vector是ArrayList的多线程的一个替代品 ArrayList实现遍历的几种方法 1234567891011121314151617181920212223242526272829303132333435package com.yonyou.test; import java.util.ArrayList;import java.util.Iterator;import java.util.List; public class Test&#123;public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;HAHAHAHA&quot;); //第一种遍历方法使用foreach遍历List for (String str : list) &#123; System.out.println(str); &#125; //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为foreach(String str:strArray)这种形式 &#123; System.out.println(strArray[i]); &#125; //第三种遍历 使用迭代器进行相关遍历 Iterator&lt;String&gt; ite=list.iterator(); while(ite.hasNext()) &#123; System.out.println(ite.next()); &#125; &#125;&#125; LinkedList LinkedList -&gt; List接口 -&gt; Collection接口LinkedListt 底层是双向链表 LinkedList的链式线性表的特点为: 适合于在链表中间需要频繁进行插入和删除操作。LinkedList的链式线性表的缺点为: 随机访问速度较慢。查找一个元素需要从头开始一个一个的找。 LinkedList的内部实现 LinkedList的内部是基于双向循环链表的结构来实现的。在LinkedList中有一个类似于c语言中结构体的Entry内部类。在Entry的内部类中包含了前一个元素的地址引用和后一个元素的地址引用类似于c语言中指针。 LinkedList不是线程安全的 注意LinkedList和ArrayList一样也不是线程安全的，如果在对线程下面访问可以自己重写LinkedLis ,然后在需要同步的方法上面加上同步关键字synchronized d.LinkedList的遍历方法 123456789101112131415161718192021222324252627282930package com.yonyou.test; import java.util.LinkedList;import java.util.List;public class Test&#123;public static void main(String[] args) &#123; List&lt;String&gt; list=new LinkedList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); //LinkedList遍历的第一种方式使用数组的方式 String[] strArray=new String[list.size()]; list.toArray(strArray); for(String str:strArray) &#123; System.out.println(str); &#125; //LinkedList遍历的第二种方式 for(String str:list) &#123; System.out.println(str); &#125; //LinkedList遍历的第三种方式（迭代器） Iterator&lt;String&gt; ite = list.iterator(); while (ite.hasNext()) &#123; System.out.println(ite.next()); &#125; &#125;&#125; LinkedList可以被当做堆栈来使用 由于LinkedList实现了接口Dueue，所以LinkedList可以被当做堆栈来使用 Set Set 具有与 Collection 完全一样的接口，只是行为上不同Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象 Set接口区别于List接口的特点在于: Set中的元素实现了不重复，有点象集合的概念，无序，不允许有重复的元素,最多允许有一个null元素对象需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是有由该元素的HashCode决定的，其具体位置其实是固定的。 此外需要说明一点，在set接口中的不重复是由特殊要求的。 举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是 如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到 Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关 HashSet HashSet的底层就是基于HashMap来实现的在HashMap中的key是不允许重复的，你换个角度看看，那不就是说Set集合吗？ 这里唯一一个需要处理的就是那个Map的value弄成一个固定值即可 HashSet使用和理解中容易出现的误区: HashSet中存放null值 HashSet中时允许出入null值的，但是在HashSet中仅仅能够存入一个null值 HashSet中存储元素的位置是固定的 HashSet中存储的元素的是无序的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的 遍历HashSet的几种方法 这里先不写了，和上面给的方法类似 TreeSet TreeSet是一种排序二叉树。存入Set集合中的值，会按照值的大小进行相关的排序操作。底层算法是基于红黑树来实现的。TreeSet和HashSet的主要区别在于TreeSet中的元素会按照相关的值进行排序 TreeSet和HashSet的区别和联系 HashSet是通过HashMap实现的,TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key Map的key和Set都有一个共同的特性就是集合的唯一性.TreeMap更是多了一个排序的功能. hashCode和equal()是HashMap用的, 因为无需排序所以只需要关注定位和唯一性即可. hashCode是用来计算hash值的,hash值是用来确定hash表索引的. hash表中的一个索引处存放的是一张链表, 所以还要通过equal方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry. put时,如果hash表中没定位到,就在链表前加一个Entry,如果定位到了,则更换Entry中的value,并返回旧value 由于TreeMap需要排序,所以需要一个Comparator为键值进行大小比较.当然也是用Comparator定位的. Comparator可以在创建TreeMap时指定 如果创建时没有确定,那么就会使用key.compareTo()方法,这就要求key必须实现Comparable接口. TreeMap是使用Tree数据结构实现的,所以使用compare接口就可以完成定位了. 下面是一个使用TreeSet的实例 123456789101112131415161718192021package com.yonyou.test; import java.util.Iterator;import java.util.TreeSet;public class Test&#123; public static void main(String[] args) &#123; //String实体类中实现Comparable接口，所以在初始化TreeSet的时候， //无需传入比较器 TreeSet&lt;String&gt; treeSet=new TreeSet&lt;String&gt;(); treeSet.add(&quot;d&quot;); treeSet.add(&quot;c&quot;); treeSet.add(&quot;b&quot;); treeSet.add(&quot;a&quot;); Iterator&lt;String&gt; iterator=treeSet.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; Map Map中的每个成员方法由一个关键字（key）和一个值（value）构成。Map包装的是一组成对的“键-值”对象的集合，而且在Map接口的集合中也不能有重复的key出现，因为每个键只能与一个成员元素相对应。Map接口不直接继承于Collection接口（需要注意） HashMap HashMap实现了Map、CloneMap、Serializable三个接口，并且继承自AbstractMap类。HashMap基于hash数组实现，若key的hash值相同则使用链表方式进行保存。 新建一个HashMap时,默认的话会初始化一个大小为16，负载因子为0.75的空的HashMap HashMap中还存在一个内部类Entry，用于链表的存储 Entry是一个结点，它持有下一个元素的引用，这样就构成了一个链表 123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Test&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;1&quot;, &quot;value1&quot;); map.put(&quot;2&quot;, &quot;value2&quot;); map.put(&quot;3&quot;, &quot;value3&quot;); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value：&quot;); for (String key : map.keySet()) &#123; System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key)); &#125; //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第四种 System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) &#123; System.out.println(&quot;value= &quot; + v); &#125; &#125;&#125; 好久没有弄，暂时就这些了]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2Farchives%2F4236377085.html</url>
    <content type="text"><![CDATA[字符串比较 如果是2个基本类型比较，是比较值是否相等 如果是2个引用类型比较，比较的是引用类型指向的内存地址 String s1=”hello”与String s2=new String(“hello”)的区别：* new的对象是在堆中存储，并且每new一次就单独申请一块新的内存 * 常量字符串在常量池(特殊的内存区域) String类在内存中管理一个字符串常量池（常量池的一部分），池中所有相同的字符串常量被合并，只占用一个空间。String s1=”hello”，先看池中有没有hello，没有就创建一个hello字符串对象。即采用此方法创建0或者1个对象。String s2=new String(“hello”),这里先在池中创建一个hello对象，同s1，然后new String()时，将hello对象复制到堆heap中，s2指向堆中的hello。采用此种方法时创建1或2个对象(当池中有hello时，创建一个对象)。 例子 1234567891011121314public class StringExp1 &#123; public static void main(String[] args) &#123; String s1 = &quot;hello java&quot;; String s2 = new String(); s2 = &quot;hello java&quot;; String s3 = new String(&quot;hello java&quot;); String s4 = new String(&quot;hello java&quot;); String s5 = &quot;hello java&quot;; System.out.println(s1==s2); System.out.println(s1==s3); System.out.println(s1==s4); System.out.println(s1==s5); &#125;&#125; 结果 1234truefalsefalsetrue 比较字符串内容是否相等 equals() 区分大小写 equalsIgnoreCase() 不区分大小写 ==是比较两个字符的首地址（两个对象是否引用同一实例） 例子 1234s1 = &quot;123qwe&quot;;s2 = &quot;123QWE&quot;;System.out.println(s1.equals(s2));System.out.println(s1.equalsIgnoreCase(s2)); 结果 12falsetrue 字符串常用方法查找字符或子字符串, 返回索引,未找到返回-1* indexOf(); 从左边开始查找第一个字符或子字符串 * lastIndexOf()查找最后一个字符或子字符串 例 12345String str = &quot;abcdefgabcabc&quot;;int i = str.indexOf(&apos;a&apos;);//查找字符System.out.println(i);i = str.indexOf(&quot;bca&quot;);//查找子字符串System.out.println(i); 结果 1208 字符串内容操作要注意的地方 注意：对字符串内容操作的函数不会作用与字符串本身，而是作为返回值返回。原因：String 类是被final修饰的 ，final修饰的对象，一旦赋值，则内存地址不能在改变,因为String对象是不能改变的，当需要更改一个字符串时，就必须将他复制到一个StringBuffered中，后者使用下列方法，在更改后会构造一个新的字符串副本。例 截取字符串 substring(10) 从第10个开始,截取到末尾 substring(5,10) 从第5个开始,截取到第10个 trim() 去掉两端空格 12345678910111213String str = &quot; abcdefgabcabc &quot;;System.out.println(str);String s = str.substring(10);System.out.println(s);s = str.substring(5,10);System.out.println(s);String tString = str.trim();System.out.println(tString);System.out.println(str); 结果 12345 abcdefgabcabc //str存在空格abcabc //str.substring(10);cdefg //str.substring(5,10);abcdefgabcabc //str.trim(); abcdefgabcabc //str依然存在空格 str本身未被改变 分割字符串 str.split(a); 根据a来分割字符串str 例 1234567891011121314151617String question = &quot;1+1=?#A:1&amp;B:2&amp;C:3&amp;D:4#B&quot;;String[] ques = question.split(&quot;#&quot;);System.out.println(&quot;题目描述:&quot;+ques[0]);System.out.println(&quot;题目选项:&quot;);String[] ops = ques[1].split(&quot;&amp;&quot;);for (String o : ops) &#123; System.out.println(o);&#125;System.out.println(&quot;答案&quot;+ques[2]); 结果 1234567题目描述:1+1=?题目选项:A:1B:2C:3D:4答案A 其他 charAt() codePointAt() replace() 例 1234567891011121314String str = &quot;abcdefgabcabc&quot;;System.out.println(str);//返回指定位置的字符char ch = str.charAt(3);System.out.println(ch);//返回指定位置字符的&lt;u&gt;unicode&lt;/u&gt;码int i = str.codePointAt(3);System.out.println(i);//把str中ab替换成sbString str2 = str.replace(&quot;ab&quot;, &quot;sb&quot;);System.out.println(str2); 结果 1234abcdefgabcabcd100sbcdefgsbcsbc]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>javase</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象(OOP)]]></title>
    <url>%2Farchives%2F2348218246.html</url>
    <content type="text"><![CDATA[面向对象(OOP) (Object Oriented Programming)面向对象的编程OOD（面向对象的设计），OOA（面向对象的分析） 分类是人们认识世界的一个很自然的过程在日常生活中会不自觉的进行分类分类要总结出类型所拥有的属性（特征）及操作（方法） 什么是对象对象：用来描述客滚事务的一个实体，由一组属性和方法构成 对象同时拥有属性和方法两项特性 对象的属性和方法通常被封装在一起，组成类，共同体现事物的特性，不能分割 什么是类类 具有相同属性和方法的一组对象的集合 类是对象的类型 不同于int类型，具有方法 对象是类的实例 类是摸具，模板，通过模具，模板做出来的实例就是对象 基本类型声明的变量称为变量名其他类型声明的变量称为对象名 以下两大点是查找资料时看到的，写的很好参考点击跳转 面向对象的优点 与人类的思维习惯一致 把人类解决问题的思维过程转变为程序能够理解的过程 信息隐藏，提高了程序的可维护性和安全性 封装实现了模板化和信息隐藏 封装使得在对象外部的不能随意访问对象的属性和方法 提高了程序的可重用性 一个类可以创建多个实例，提高可重用性 面向对象的三大特性 封装 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性 继承 提高代码复用性；继承是多态的前提 多态 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性 面向对象的五大基本原则 单一职责原则SRP(Single Responsibility Principle) 类的功能要单一，不能包罗万象，跟杂货铺似的 开放封闭原则OCP(Open－Close Principle) 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意 里式替换原则LSP(the Liskov Substitution Principle LSP) 子类可以替换父类出现在父类能够出现的任何地方。 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的是抽象的中国人，而不是你是xx村的。 接口分离原则ISP(the Interface Segregation Principle ISP) 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多 方法方法的几要素 访问权限 方法的返回值 方法的名称 方法的参数 方法的参数就是方法运行的必要条件 如何定义一个方法 思考这个方法所要完成的功能是什么 这个方法需不需要返回值 两种情况 如果方法具有返回值，方法中必须使用关键字return返回该值，返回类型为该返回值的类型 如果方法没有返回值，返回类型为void 方法名（跟功能相关的单词） 需不需要参数 方法调用 同一个类之间的成员方法 可以互相调用 不同类之间方法调用的步骤: 要先new类的对象 再 通过对象名.方法名()调用 变量 局部变量 在方法内部定义的变量一般称为局部变量，局部变量的作用域为定义位置的后面 在循环中定义的变量只对循环内部有效 成员变量 在类中定义的属性称为类的成员变量 成员变量的作用域为：类的所有非static方法 成员变量和局部变量的区别: 作用域不同 局部变量的作用域仅限于定义它的方法 成员变量的作用域在整个类内部都是可见的 初始值不同 Java会给成员变量一个初始值 Java不会给局部变量赋予初始值 局部变量在同一个花括号内部中，不允许有同名局部变量；在不同的花括号中，可以有同名局部变量 两类变量同名时，局部变量具有更高的优先级]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>javase</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（后续）]]></title>
    <url>%2Farchives%2F3972042800.html</url>
    <content type="text"><![CDATA[JavaScript （后续：1）alert();警告框prompt():输入框 返回输入的值confirm():确认框 返回值：true/false//相当于window.confirm(); js自定义函数的语法function 函数名(参数（形参）列表){ } 系统函数 parseInt 把字符串类型转换成number类型变量 parseFloat 把字符串小数转换成number类型变量 isNaN() 判断变量是否是 非数字 history.back(); 返回上一页 history.forward() 前往下一页 history.go(); history.go(1) 前往下一页 history.go(-1) 返回上一页 history.go(2) 前往下两页 history.go(-2) 返回上两页 loadtion.reload() 刷新当前页面 var date = new Date();获取当前系统时间 date.getFullYear() 获取4位年份 date.getMinutes()+1; 月份 date.getDate();获取当前日 date.getHours();获取当前小时 date.getMinutes()获取分钟 date.getSeconds()获取秒 date.getMilliseconds()//毫秒 常用的事件 onclick() 单击事件 onkeydown() 键盘敲击事件 onmouseover() 鼠标移入元素 onmouseout() 鼠标移开元素 onload() 页面加载完成后执行的方法 onchange() 表单元素被改变内容 js中的定时器 setTimeout（）； 设置一次性的闹钟 如： var tm=setTImeout（“test（）”，3000）3秒后调用test函数 (这里返回的值是定时器的标识) clearTimeout(); 清除一次性的定时器 如：clearTimeout(tm); (这里的tm是上面的变量，即是定时器的标识) setInterval() ; 设置循环闹钟 如： var am=setInterval（“test（）”，3000）3秒后调用test函数 (这里返回的值是定时器的标识) clearInterval() 清除循环闹钟 如：clearInterval(am); (这里的am是上面的变量，即是定时器的标识) js标签对象 innerText获取或者设置标签里面的文本内容(不包括子标签) innerHTML获取或设置标签里面的所有HTML文本(包括子标签及普通文本) getElementById() 返回对拥有指定id的第一个对象的引用getElementsByName() 返回带有指定名称的对象的集合getElementsByTagName() 返回带有指定标签名的对象的集合getElementsByClassName() 返回带有指定class名称的对象集合write() 向文档写文本、HTML表达式或JavaScript代码 js变量的作用域： 局部变量 在函数内部定义的变量， 旨在函数内部有效，并且在定义的后面 全局变量 不是在函数内部定义的变量 在&lt;script&gt;中定义的变量，对整个页面都有效 数组数组也是一种变量，这种变量代表多个值数组对象是使用单独的变量名来存储一系列的值 1234567//声明数组var array = new Array();//给数组中的元素赋值，下标从0开始array[0] = 111;array[1] = 222;array[2] = 333;//array.length 返回数组的长度]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2Farchives%2F3424359953.html</url>
    <content type="text"><![CDATA[JavaScript什么是JavaScript（js） js是浏览器客户端的一种语言（浏览器是js程序的运行时的环境） js主要的作用就是用来操作html、css 网页中的特效代码都是用js实现的 例如：悬浮广告轮播图 JavaScript的组成 ecmascript js的基本语法：for，while，dowhile循环 if语句，数组，变量，数据类型 document操作 html，css的操作 bom 浏览器窗口的一些操作 回到上一页，下一页 弹窗 js脚本的使用方式 在html的文件内部的任意地方加入 123&lt;script type=&quot;text/javascript&quot;&gt; //代码部分&lt;/script&gt; 链接外部js文件 1&lt;script src=&quot;外部js文件&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 简短缩写方式 1&lt;a href=&quot;javascript:js代码&quot;&gt;a的js应用&lt;/a&gt; JavaScript 能够以不同方式“显示”数据 使用 window.alert() 写入警告框 使用 document.write() 写入 HTML 输出 使用 console.log() 写入浏览器控制台 使用 innerHTML 写入 HTML 元素 变量的使用和声明js中定义变量 统一用关键字var 或者直接使用变量，无需定义 js中变量的声明和赋值 只定义没有赋值 123var width，height;width=5;//之后单独赋值height=10; 定义并且同时赋值 1var width=5,height=10; 不定义直接赋值 1height = 999 ; js的几种数据类型 undefined 未定义 一个变量没有赋值 boolean 只有true/false两种值 number 数字类型（整数或小数） string 字符串类型 一般情况string都是用双引号或者单引号括起来 object 对象类型 typeof() 可以检测变量数据类型以下例子： 123456var a;//没有赋值，undefined类型var b = 12.2;//number类型var c = &quot;12.2&quot;;//string类型var is = true;//boolean类型var n = null;//object类型document.write(typeof(a));//检测a的数据类型类型 字符串的 双引号问题 在一个双引号字符串之间如果要加入双引号有三种方法：1：不加双引号：没有严重的影响(不推荐)2：用单引号代替3：用转义字符-&gt; \” 例1： 1234//用转义字符var str = &quot;&lt;div style=\&quot;width:&quot;+a+&quot;px\&quot;&gt;&lt;/div&gt;&quot;;//用单引号代替var str2 = &quot;&lt;div style=&apos;width:&quot;+a+&quot;px&apos;&gt;&lt;/div&gt;&quot;; 例2: 1234567var a = 100;var str = &quot;&lt;div style=\&quot;&quot;+ &quot;width:&quot; + a + &quot;px;&quot;+ &quot;height: 100px;&quot; + &quot;border: 1px solid red;&quot;+ &quot;\&quot;&gt;&lt;/div&gt;&quot;;document.write(str); javascript运算符 算数运算符 + - * / % ++ – 赋值运算符 = 比较运算符 &lt; &gt; &lt;= &gt;= == != === 逻辑运算符 &amp;&amp; &#124; &#124; ! 在一个js的运算表达式中，如果都是number类型，则整个结果也是number类型表达式是从左到右开始运算，一旦遇到字符串，则后面的运算全部是字符串连接 例1 123456789var x = 3;var y = 5;var z = 10;var ch = &quot;字符&quot;;document.write(x + z + ch + x + z+&quot;&lt;br/&gt;&quot;);var n = null;n = z/x;document.write(&quot;n=&quot;+n+&quot;:&quot;+typeof(n)+&quot;&lt;br/&gt;&quot;);//除法 10/3会得到小数 而不是 3 例1结果：后面的x+z 变为了字符连接。如下图 例2关于 表达式简写 下面以 + 为例（+ - * / % 用法一样） 123456var n = 1;n = n + 1;document.write(&quot;n=&quot;+ n + &quot;,&quot; +&quot;&lt;br/&gt;&quot;);var n = 1;n += 1;document.write(&quot;n=&quot;+ n + &quot;,&quot; +&quot;&lt;br/&gt;&quot;); 例2结果： 例3自增运算符：++ （自减运算符：–，用法一样） 1234n = z++;//先把z的值赋值给n，再自己加1document.write(n + &quot;,&quot; + z +&quot;&lt;br/&gt;&quot;);n = ++z;//z先加1，再赋值给ndocument.write(n + &quot;,&quot; + z +&quot;&lt;br/&gt;&quot;); 例3结果： 例4js中对于 == 和 ===的区别 123456var i=2;var ch = &quot;2&quot;document.write(i==ch);//显示truedocument.write(&quot;&lt;br/&gt;&quot;);//换个行document.write(i === ch);//显示false//===会先判断类型是否相等 例4结果: 逻辑运算符 &amp;&amp; 逻辑与 true &amp;&amp; true 表达式返回true 两边都为真 返回真 || 逻辑或 false &amp;&amp; true 表达式返回true 只要一边为真 返回真 ！逻辑非 !true 返回假 !false 返回真 真变成假 假变成真]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2Farchives%2F3999917138.html</url>
    <content type="text"><![CDATA[csscss的作用 美化网页 设置字体的大小 设置容器的位置，大小 设置图片 写css样式的方法 内部样式 在head标签里面加上 12&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; 行内样式 在标签里面加上style=”” 外部样式 连接一个专门的css文件 css基本语法 选择器(即要修饰的对象){ css属性1:属性值1; css属性2:属性值2; } 例如： 1234567p&#123; border-radius: 2.5em; background-color: rgba(255, 169, 88, 0.12); text-align: center; font-size: 13px;/*改变字体大小*/ color: red;/*改变字体颜色*/&#125; 选择器的分类 标签选择器 类选择器 给标签取个class名字 css用 .class名{ } 例如： 12345.li1&#123; font-size: 20px; color: #000; font-family: 华文宋体;&#125; id选择器 给标签取个唯一id css用 #id{ } 例如： 12345#li1&#123; text-decoration: overline; font-size: 16px; letter-spacing: 15px;&#125; 后代选择器 选择该元素的所有后代,无论第几代 子代选择器 只选择第一代 兄弟选择器 查找id=li1的元素后面的所有兄弟元 相邻兄弟选择器 查找id=li1的元素后面的第一个为li标签的兄弟元优先级id&gt;class&gt;子代&gt;后代 css属性文本属性 font-family:字体Font-size:字体大小Font-weight:是否加粗color设置颜色Text-indent:首行缩进text-align：center/left/right对齐Line-height:最主要的作用是设置文字相对容器垂直居中如果line-height等于height，文字就会垂直居中white-space: pre;/保留空白字符/white-space: normal;/忽略空白字符/ 背景属性 Background-color:背景颜色Background-image:url(“图片地址”)背景图片Background-repeat:（背景重复方式）repeat（重复，默认）no-repeat(不重复)Repeat-x（x轴上重复）Repeat-y（y轴上重复）Background-positionn: -20px 10px (控制背景图片的位置，将背景图片向左偏移20px，向下偏移10px) 其他属性 text-decoration：（加下划线）underline下划线line-through 删除线overline 上划线none 不需要线letter-spacing:（设置文字之间的间距）数字px; list-style：none；（去掉li前的圆心）square;(改为矩形矩形)circle；（空心圆）disc；（实心圆，默认） 盒子模型一个盒子（容器）是由4部分组成的： 里面的内容（元素内容） 內边距（容器与内容之间的距离） padding设置 padding-left: padding-top: padding-right: padding-bottom: 缩写形式1：padding：10px,10px,10px,10px;(上右下左) 缩写形式2：padding：10px,20px;(上下10，左右20) 外边距（容器与外部的距离） margin设置 margin-left: margin-top: margin-right: margin-bottom: 缩写形式：margin：10px,10px,10px,10px;(上右下左) 缩写形式2：margin：10px,20px;(上下10，左右20) 边框（边框线） border设置 例：12345678.box&#123; width: 300px; height: 200px; border: 1px solid red; padding-left: 20px; padding-top: 20px; margin-top: 30px;&#125; 常用水平居中的方法：（容器相对于外部容器）12345.box&#123; width: 300px; height: 200px; margin: 0px auto;&#125; 容器的实际宽高=css设置的宽高+边框的大小+padding]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是HTML]]></title>
    <url>%2Farchives%2F625187715.html</url>
    <content type="text"><![CDATA[什么是HTML html是超文本标记语言 html就是用来做网站前端的 偏硬件 汇编语言c语言c++ 偏向应用 java:网站应用系统。数据分析，安卓的appc# 浏览器： ”解释和执行“HTML的工具 html主要有若干个标签组成： html标签分为块状标签和行级标签 块状标签: 独占一行或者前后隔一空行 标题h1 标题h2 标题h3 标题h4 标题h5 标题h6123456&lt;h1&gt;标题h1&lt;/h1&gt;&lt;h2&gt;标题h2&lt;/h2&gt;&lt;h3&gt;标题h3&lt;/h3&gt;&lt;h4&gt;标题h4&lt;/h4&gt;&lt;h5&gt;标题h5&lt;/h5&gt;&lt;h6&gt;标题h6&lt;/h6&gt; 段落标签1&lt;p&gt;段落标签&lt;/p&gt; 水平线标签 1&lt;hr&gt; 段落标签和h标签的区别是：1：h标签字体加粗加大2：p段落标签是网页默认字体 有序列表标签 1234&lt;ol&gt;&lt;li&gt;淘宝&lt;/li&gt;&lt;li&gt;京东&lt;/li&gt;&lt;/ol&gt; 无序列表标签如： 淘宝 京东1234&lt;ul&gt;&lt;li&gt;淘宝&lt;/li&gt;&lt;li&gt;京东&lt;/li&gt;&lt;/ul&gt; 商品某某 价格：199 库存：99定义描述标签12345&lt;dl&gt;&lt;dt&gt;商品某某&lt;/dt&gt;&lt;dd&gt;价格：199&lt;/dd&gt;&lt;dd&gt;库存：99&lt;/dd&gt;&lt;/dl&gt; 表格标签12345&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 行级标签：不独占一行图像标签：在网页中插入图片1&lt;img src=&quot;../images/b2.jpg&quot; alt=&quot;图片&quot; width=&quot;250&quot; height=&quot;250&quot; title=&quot;ssss&quot;&gt; 12&lt;span&gt;&lt;/span&gt;范围标签&lt;br/&gt;换行标签]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习惯的开始]]></title>
    <url>%2Farchives%2F3717175919.html</url>
    <content type="text"><![CDATA[习惯的开始最近开始在系统的学习jee了，争取每几节课都能给自己做个知识总结，或者说是笔记，备忘吧！试着开始这样的学习希望能坚持一点时间]]></content>
      <categories>
        <category>jee学习之路</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle10g在win7下的安装]]></title>
    <url>%2Farchives%2F2261899728.html</url>
    <content type="text"><![CDATA[oracle10g在win7x64下的安装 最近学oracle数据库，教的是10g版的，先试着安装 下载合适的版本，官网上10g版本现在是找不到下载的，大家可以自行百度（这里给些链接，复制链接到迅雷下载） http://download.oracle.com/otn/nt/oracle10g/10201/102010_win64_x64_database.zip 如果是win7 64位,可能上面的版本还是无法安装，需要下载下面的这个版本: http://download.oracle.com/otn/nt/oracle10g/10204/10204_vista_w2k8_x64_production_db.zip 下载之后，如果直接安装还是会出问题的，所以在安装之前需要修改一些文件 解压安装包，进入安装包目录 进入 安装包/database/install/ 路径下 修改oraparam.ini文件，找到 Windows=5.0,5.1,5.2,6.0修改如下： 12CERTIFIED_VERSION_FAILURE_MESSAGEWindows=5.0,5.1,5.2,6.0,6.1 在安装包搜索 refhost.xml 文件，搜索到两个文件，都需要修改，如下: 1234567&lt;!--Microsoft Windows Vista--&gt;&lt;OPERATING_SYSTEM&gt; &lt;VERSION VALUE=&quot;6.0&quot;/&gt;&lt;/OPERATING_SYSTEM&gt;&lt;OPERATING_SYSTEM&gt; &lt;VERSION VALUE=&quot;6.1&quot;/&gt;&lt;/OPERATING_SYSTEM&gt; 说明：6.1表示windows的内核版本，Windows 7的内核版本号为6.1 修改完成后 ，再去安装基本不会出问题。不过我安装的时候，报错：启动 Database Control 时出错，导致OracleDBConsoleorcl（数据库控制台服务）没有开启，使用时发现OEM无法使用，只能用iSQLplus和SQLplus工具以前安装12c的时候按照网上教程倒没有什么问题，不知道哪里还需要修改的。emmm…先这样吧。。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+Next主题]]></title>
    <url>%2Farchives%2F524570569.html</url>
    <content type="text"><![CDATA[安装next主题1git clone https://github.com/theme-next/hexo-theme-next themes/next 启用主题修改博客根目录下的配置文件_config.yml:1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题设定修改Next目录下的配置文件_config.yml:搜索字段：Scheme 可找到以下内容： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 左侧网站信息及目录，块+片段结构布局 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶管理hexo博客]]></title>
    <url>%2Farchives%2F2002852375.html</url>
    <content type="text"><![CDATA[进阶管理hexo博客这几天，重新安装windows系统，好多东西都要重新来过，太麻烦了，所以网上查找了一些解决方案并记录下来 解决方案： 在你的github上新建一个repository，然后把你的blog文件夹上传，进行备份，这个比较简单 在现有的shuisuinian.guthub.io的repository下创建一个分支来管理，具体操作步骤如下： 具体操作： 按本地磁盘（任意位置下，右键打开Git bash,将你的项目文件克隆到本地： 1git clone git@github.com:shuisuinian/shuisuinian.github.io.git 这时该目录下出现一个shuisuinian.github.io的文件夹，进入该文件夹，删除文件夹中除了.git的其他所有文件夹 把你的blog文件夹内的所有文件全部复制到shuisuinian.github.io/下 此时，应有一个名.gitignore的文件，如果没有则自己创建，内容如下：1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 说明：.gitignore文件就是为了指定哪些文件上传的时候可以忽略，因为blog/的文件并不全部都需要 用git命令创建一个叫hexo（任意命名）的分支，并切换到此分支： 1git checkout -b hexo 以此输入以下命令 123git add --allgit commit -m &quot;注释&quot;git push --set-upstream origin hexo 后续：发表更新博客及源文件 git 提交三部曲 1234567// 更新源文件git add . #添加所有文件到暂存区git commit -m &quot;提交一篇博客&quot; #提交git push origin hexo 推送hexo分支到github// 更新博客hexo ghexo d 利用hexo把本地文章部署到了网站上，网站更新==shuisuinian.github.io下的master分支更新==blog/public/下文件更新，然后通过git三部曲把本地变更过的blog文件也备份到了shuisuinian.github.io下的hexo分支 今后换电脑或者重装系统后，安装基本软件环境后，cnpm安装依赖1git clone -b hexo git@github.com:shuisuinian/shuisuinian.github.io.git]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Farchives%2F1243066710.html</url>
    <content type="text"><![CDATA[欢迎进入wyf’s blogWelcome to wyf-Hexo-coding pages!Welcome to wyf-Hexo-github pages! 之后是第一次搭建hexo时自动创建hello worldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2Farchives%2F3442686983.html</url>
    <content type="text"><![CDATA[单例设计模式必须对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。 1.如何保证对象的唯一性 不允许该类创建一个本类实例 对该类创建一个本类实例 对外提供一个方法让其他程序可以获取该对象 2.步骤： 私有化该类构造函数 通过new在本类中创建一个本类对象 定义一个公有的方法，将创建的对象返回 3.例如：新建一个测试类 1234567891011121314151617class Test&#123; private int num; private static Test t = new Test(); //通过new在本类中创建一个本类对象 private Test()&#123;&#125; //私有化构造函数 public static Test getInstance()&#123; //定义一个公有的方法，将创建的对象返回 return t; &#125; public void setNum(int num)&#123; this.num = num; &#125; public int getNum()&#123; return num; &#125; &#125; 如果在main中直接new两个对象 方式1 12345678910class Demo&#123; public static void main(String[] args)&#123; Test t1 = new Test(); Test t2 = new Test(); t1.setNum(10); t2.setNum(20); System.out.println(t1.getNum()); System.out.println(t2.getNum()); &#125;&#125; 输出结果为 121020 未达到内存中只有一个对象的要求 方式212345678910class Demo&#123; public static void main(String[] args)&#123; Test t1 = Test.getInstance(); Test t2 = Test.getInstance(); t1.setNum(10); t2.setNum(20); System.out.println(t1.getNum()); System.out.println(t2.getNum()); &#125;&#125; 输出结果为 122020 利用此方法t1 t2操作的时同一个对象吗，所以满足内存了中只有一个对象的要求 4.饿汉式 （开发时常用） 12345678910 class Single &#123; // 类一加载，对象就已经存在了 private Static Single s = new Single(); private Single()&#123;&#125; public static Single getInstance()&#123; return s; &#125;&#125; 5.懒汉式 (面试时较前者更常问) 12345678910111213 class Single2 &#123; // 类加载进来，没有对象，只有调用了getInstance方法时，才会创建对象 //延迟加载形式 private Static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javase</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo创建]]></title>
    <url>%2Farchives%2F469202525.html</url>
    <content type="text"><![CDATA[hexo 静态博客1、 安装node.js直接在官网下载 ，安装首先验证是否安装成功进入cmd（快捷键 win+R，输入cmd），或者git bash 12node -vnpm -v 出现版本号XXX 就是安装没有问题（一般也不会出现问题的） 2、更换源（改为淘宝源） 直接npm比较慢，所以安装cnpm，这样会快些1npm install -g cnpm --registry=https://registry.npm.taobao.org 键入命令后回车cnpm -v 进行验证 ,和上面验证一个意思，就不截图了 3、现在使用cnpm 来安装hexo博客框架1cnpm install -g hexo-cli hexo -v 进行验证 4、新建一个文件夹blog进入该文件夹，再执行命令123mkdir blog //新建文件夹blog 文件夹名自己随意就好cd blog //进入该文件夹hexo init //在这个文件夹建立hexo博客 等待一段时间安装 出现Start blogging with Hwxo!表示安装成功之后就算出现什么问题，直接删掉这个文件夹，重来就好 后面的操作都是在这个新建的blog目录下，就算出现什么问题，直接删掉这个文件夹，重来就好 5、启动博客hexo s浏览器进入 localhost:4000 发现有一个默认创建的文章(我这里目录不一样，是在之后做了修改) 6、新建博文1hexo n &quot;我的第一篇hexo文章” 可以发现在目录/blog/source/_psots文件夹下 多出一个“我的第一篇hexo文章.md” 的文件，这里是markdown格式的，大家可以花个几分钟去学习一下语法，比较简单。 7、部署到github上在github里新建一个repostory命名 ！！！！你的用户名.github.io12# 例如我的shuisuinian.github.io 8、安装插件，并修改_config.yml文件还是 cmd 进入blog目录下cnpm install --save hexo-deployer-git 安装时有个 peerDependencies WARNING 不用管 设置_config.yml 文件（这个文件就在blog根目录下的） 找到这一段12 # Deployment## Docs: https://hexo.io/docs/deployment.html 修改：123456 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/你的用户名/你的用户名.github.io.git banch: master 设置完成后推送到github，依次执行 12hexo ghexo d 这里可能会出现的问题是：你以前安装完git，没有配置信息等一些问题，如果有问题，大家可以百度一下 9、更换主题 git clone https://github.com/litten/hexo-theme-yilia.git. themes/yilia 修改 之前的_config.yml 找到 theme 这行 修改为theme: yilia 执行以下命令1234hexo cleanhexo ghexo shexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
      </tags>
  </entry>
</search>
